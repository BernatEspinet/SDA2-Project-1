# -*- coding: utf-8 -*-
"""eval.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AkJ9xGuZz6OKjzxFehxbg-O0sSm5hN4b
"""

from google.colab import drive #Optional way to load data
drive.mount('/content/drive')
!pip install anndata
import anndata as sc
import numpy as np
import torch
import torch.nn as nn
import torch.nn.functional as F
from torch.utils.data import DataLoader
import pandas as pd

#load Models

def sample_from_latent(mu, logvar):
    std = logvar.mul(0.5).exp_()
    eps = torch.empty_like(std).normal_()
    return eps.mul(std).add_(mu)

def sample_from_latent_exp(latent_lambda):
    return torch.empty_like(latent_lambda).exponential_()

test_adata = sc.read_h5ad("/content/drive/My Drive/project 1/SAD2022Z_Project1_GEX_test.h5ad")
preprocessed_test = test_adata.layers['counts'].toarray()

i=0
for column in preprocessed_test:
  preprocessed_test[i] = column/max(column)
  i+=1

test_tensor = torch.from_numpy(preprocessed_test)
test_tensor = torch.reshape(test_tensor, (18052,1,5000))

vae16 = torch.load('vae16.pth')
vae32 = torch.load('vae32.pth')
vae64 = torch.load('vae64.pth')
vae64_e = torch.load('vae64_e.pth')


vae16.eval()
first = True
for tensor_batch in test_tensor:
    with torch.no_grad():
      tensor_batch = tensor_batch.to(device)
      tensor_batch_recon, latent_mu, latent_logvar = vae16(tensor_batch)
      latent_sample = sample_from_latent(latent_mu,latent_logvar).to("cpu").detach().numpy()
      if(first):
        latent_matrix = latent_sample
        first=False
      else:
        latent_matrix = np.vstack((latent_matrix, latent_sample))

var_matrix = np.var(latent_matrix, axis = 0)
norm_var_matrix = np.sort(var_matrix/sum(var_matrix),axis=0)[::-1]
acc_var = 0
n = 0
for element in norm_var_matrix:
  if acc_var < 0.95:
    acc_var+=element
    n+=1
print(str(n)+' Principal components explain '+str(acc_var*100)+'% of the variance')

ind = np.argpartition(norm_var_matrix, -2)[-2:] #Get the index of the top 2 principal components
top2 = latent_matrix.T[ind] #Get values of the top 2 principal components
types = list(test_adata.obs.cell_type) #Get cell type
le = preprocessing.LabelEncoder()
types = le.fit_transform(types) #Encode cell type to plot by color
plt.figure(figsize=(10, 10), dpi=80)
plt.scatter(top2[0],top2[1], c = types)
plt.title("Visual representation of top 2 PCA VAE 16")

vae32.eval()
first = True
for tensor_batch in test_tensor:
    with torch.no_grad():
      tensor_batch = tensor_batch.to(device)
      tensor_batch_recon, latent_mu, latent_logvar = vae32(tensor_batch)
      latent_sample = sample_from_latent(latent_mu,latent_logvar).to("cpu").detach().numpy()
      if(first):
        latent_matrix = latent_sample
        first=False
      else:
        latent_matrix = np.vstack((latent_matrix, latent_sample))

var_matrix = np.var(latent_matrix, axis = 0)
norm_var_matrix = np.sort(var_matrix/sum(var_matrix),axis=0)[::-1]
acc_var = 0
n = 0
for element in norm_var_matrix:
  if acc_var < 0.95:
    acc_var+=element
    n+=1
print(str(n)+' Principal components explain '+str(acc_var*100)+'% of the variance')

ind = np.argpartition(norm_var_matrix, -2)[-2:] #Get the index of the top 2 principal components
top2 = latent_matrix.T[ind] #Get values of the top 2 principal components
types = list(test_adata.obs.cell_type) #Get cell type
le = preprocessing.LabelEncoder()
types = le.fit_transform(types) #Encode cell type to plot by color
plt.figure(figsize=(10, 10), dpi=80)
plt.scatter(top2[0],top2[1], c = types)
plt.title("Visual representation of top 2 PCA VAE 32")

vae64.eval()
first = True
for tensor_batch in test_tensor:
    with torch.no_grad():
      tensor_batch = tensor_batch.to(device)
      tensor_batch_recon, latent_mu, latent_logvar = vae64(tensor_batch)
      latent_sample = sample_from_latent(latent_mu,latent_logvar).to("cpu").detach().numpy()
      if(first):
        latent_matrix = latent_sample
        first=False
      else:
        latent_matrix = np.vstack((latent_matrix, latent_sample))

var_matrix = np.var(latent_matrix, axis = 0)
norm_var_matrix = np.sort(var_matrix/sum(var_matrix),axis=0)[::-1]
acc_var = 0
n = 0
for element in norm_var_matrix:
  if acc_var < 0.95:
    acc_var+=element
    n+=1
print(str(n)+' Principal components explain '+str(acc_var*100)+'% of the variance')

ind = np.argpartition(norm_var_matrix, -2)[-2:] #Get the index of the top 2 principal components
top2 = latent_matrix.T[ind] #Get values of the top 2 principal components
types = list(test_adata.obs.cell_type) #Get cell type
le = preprocessing.LabelEncoder()
types = le.fit_transform(types) #Encode cell type to plot by color
plt.figure(figsize=(10, 10), dpi=80)
plt.scatter(top2[0],top2[1], c = types)
plt.title("Visual representation of top 2 PCA VAE 64")

vae64_e.eval()
first = True
for tensor_batch in test_tensor:
    with torch.no_grad():
      tensor_batch = tensor_batch.to(device)
      tensor_batch_recon, latent_lambda = vae64_e(tensor_batch)
      latent_sample = sample_from_latent_exp(latent_lambda).to("cpu").detach().numpy()
      if(first):
        latent_matrix = latent_sample
        first=False
      else:
        latent_matrix = np.vstack((latent_matrix, latent_sample))

var_matrix = np.var(latent_matrix, axis = 0)
norm_var_matrix = np.sort(var_matrix/sum(var_matrix),axis=0)[::-1]
acc_var = 0
n = 0
for element in norm_var_matrix:
  if acc_var < 0.95:
    acc_var+=element
    n+=1
print(str(n)+' Principal components explain '+str(acc_var*100)+'% of the variance')

ind = np.argpartition(norm_var_matrix, -2)[-2:] #Get the index of the top 2 principal components
top2 = latent_matrix.T[ind] #Get values of the top 2 principal components
types = list(test_adata.obs.cell_type) #Get cell type
le = preprocessing.LabelEncoder()
types = le.fit_transform(types) #Encode cell type to plot by color
plt.figure(figsize=(10, 10), dpi=80)
plt.scatter(top2[0],top2[1], c = types)
plt.title("Visual representation of top 2 PCA VAE 64")